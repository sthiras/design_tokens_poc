import { DesignSystemVersion } from '../../core/SDKDesignSystemVersion';
import { TokenGroup } from '../../model/groups/SDKTokenGroup';
import { Token } from '../../model/tokens/SDKToken';
import { DTProcessedTokenNode } from './utilities/SDKDTJSONConverter';
import { DTTokenMergeDiff } from './utilities/SDKDTTokenMerger';
import { Brand } from '../../core/SDKBrand';
import { TokenTheme } from '../../model/themes/SDKTokenTheme';
import { DTPluginToSupernovaMap, DTPluginToSupernovaMapPack, DTPluginToSupernovaSettings } from './utilities/SDKDTMapLoader';
export declare type SupernovaToolsDesignTokensLoadingResult = {
    processedNodes: Array<DTProcessedTokenNode>;
    tokens: Array<Token>;
    groups: Array<TokenGroup>;
};
export declare type SupernovaToolsDesignTokensResult = {
    map: Pick<DTPluginToSupernovaMap, 'bindToBrand' | 'bindToTheme' | 'pluginSets' | 'pluginTheme' | 'type'>;
    tokensCreated: Array<string>;
    tokensUpdated: Array<string>;
    tokensDeleted: Array<string>;
};
/** Design Tokens Plugin Manipulation Tool */
export declare class SupernovaToolsDesignTokensPlugin {
    private version;
    private sortMultiplier;
    constructor(version: DesignSystemVersion);
    synchronizeTokensFromData(data: object, mapping: DTPluginToSupernovaMapPack, settings: DTPluginToSupernovaSettings): Promise<boolean>;
    synchronizeTokensFromDataWithResults(data: object, mapping: DTPluginToSupernovaMapPack, settings: DTPluginToSupernovaSettings): Promise<SupernovaToolsDesignTokensResult[]>;
    private processTokenNodes;
    private setTokensOrigin;
    /** Creates pure tree for validation purposes, ignoring any existing token state in workspaces. This method works offline. */
    createPureTokenTree(processedNodes: Array<DTProcessedTokenNode>, verbose: boolean): Promise<{
        tokens: Array<Token>;
        groups: Array<TokenGroup>;
    }>;
    /** Loads remote source connected to this tool, then merges tokens and groups with it, creating union. Can optionally write to the source as well */
    mergeWithRemoteSource(processedNodes: Array<DTProcessedTokenNode>, brand: Brand, write: boolean, verbose: boolean, preciseCopy: boolean): Promise<{
        tokens: Array<Token>;
        groups: Array<TokenGroup>;
        diff: DTTokenMergeDiff;
    }>;
    /** Loads remote source connected to this tool, then creates the diff from the base tree and updates the associated theme. Can optionally write to the source as well */
    mergeThemeWithRemoteSource(processedNodes: Array<DTProcessedTokenNode>, brand: Brand, theme: TokenTheme, write: boolean, verbose: boolean, preciseCopy?: boolean): Promise<{
        theme: TokenTheme;
        tokens: Array<Token>;
    }>;
    correctSortOrder(tokens: Array<Token>, tokenGroups: Array<TokenGroup>): void;
    correctSortOrderFromTypeRoot(root: TokenGroup, tokenMap: Map<string, Token>, groupMap: Map<string, TokenGroup>): void;
    flattenedIdsFromRoot(root: TokenGroup, tokenMap: Map<string, Token>, groupMap: Map<string, TokenGroup>): Array<string>;
}
